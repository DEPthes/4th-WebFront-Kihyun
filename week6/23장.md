# 23장 실행 컨텍스트

실행 컨텍스트는 자바스크립트가 코드를 이해하고 실행하는 방식의 핵심 원리이다. 이것을 알면 스코프, 호이스팅, 클로저, 비동기 처리 같은 중요한 동작들이 왜 그렇게 되는지 파악할 수 있다. 용어가 조금 어려워 보일 수 있지만, 원리는 생각보다 복잡하지 않다.

## 23.1 소스코드의 타입

자바스크립트는 소스코드를 크게 4가지 타입으로 구분하며, 각 타입의 코드는 자신만의 실행 컨텍스트를 만들어낸다.

| 소스코드의 타입 | 설명                                                   |
| :-------------- | :----------------------------------------------------- |
| **전역 코드**   | 전체 프로그램을 아우르는 가장 바깥쪽 영역의 코드이다.  |
| **함수 코드**   | 함수 내부에 작성된 코드이다.                           |
| **eval 코드**   | `eval` 함수를 통해 문자열 형태로 실행되는 코드이다.    |
| **모듈 코드**   | ES6 모듈 문법(`import`, `export`)을 사용하는 코드이다. |

소스코드 타입에 따라 실행 컨텍스트를 만들고 관리하는 방식이 조금씩 다르기 때문에 이렇게 구분한다. 예를 들어 전역 코드는 전역 스코프와 전역 변수를, 함수 코드는 지역 스코프와 지역 변수 등을 관리하기 위해 각각 실행 컨텍스트를 생성한다.

## 23.2 소스코드의 평가와 실행

자바스크립트 엔진은 코드를 바로 실행하지 않고, 두 단계를 거쳐 처리한다.

1.  **소스코드 평가 단계**: 코드를 실행하기 위한 준비 단계이다.

    - 실행 컨텍스트를 만든다.
    - 변수 선언문 (`var`, `let`, `const`)이나 함수 선언문 등을 먼저 찾아 처리한다.
    - 이때 찾아낸 변수나 함수 이름(식별자)을 실행 컨텍스트 내부의 스코프에 기록한다. (`var`의 경우 `undefined`로 초기화, 함수 선언은 함수 자체로 초기화)

2.  **소스코드 실행 단계** (런타임): 평가가 끝나면 코드를 실제로 실행한다.
    - 선언문을 제외한 나머지 코드를 한 줄씩 순서대로 실행한다.
    - 변수에 값을 할당하거나, 함수를 호출하는 등의 작업을 한다.
    - 이때 필요한 변수 값이나 함수는 실행 컨텍스트의 스코프에서 찾아 사용한다.
    - 실행 결과(예: 변수 값 변경)는 다시 실행 컨텍스트의 스코프에 반영된다.

간단히 말해, 엔진은 코드를 한번 훑어보며(평가) 변수나 함수가 뭐가 있는지 파악하고 자리를 마련한 다음, 다시 코드를 보며(실행) 실제 작업을 처리한다고 생각할 수 있다.

```javascript
var x; // 평가 단계: x를 스코프에 등록하고 undefined로 초기화
x = 1; // 실행 단계: 스코프에서 x를 찾아 1을 할당
```

## 23.3 실행 컨텍스트의 역할

실행 컨텍스트는 자바스크립트 코드가 돌아가는 데 필요한 모든 것을 관리하는 작업 환경이자 영역이다. 구체적으로 다음과 같은 핵심 역할을 한다.

1.  **스코프와 식별자 관리**: 어떤 변수나 함수가 어디(어떤 스코프)에 속하는지, 현재 값은 무엇인지 등을 기록하고 관리한다. 이것은 실행 컨텍스트 내부의 **렉시컬 환경**이라는 곳에서 이루어진다.
2.  **코드 실행 순서 관리**: 코드가 어떤 순서로 실행되고, 함수 호출 시 어디로 갔다가 어디로 돌아와야 하는지 등을 관리한다. 이것은 **실행 컨텍스트 스택**이라는 것을 통해 이루어진다.

예를 들어, 전역에 변수가 있고 함수가 호출되면 다음과 같이 동작한다.

- **전역 코드 평가**: 전역 변수, 전역 함수를 파악하여 전역 실행 컨텍스트의 전역 스코프에 등록한다.
- **전역 코드 실행**: 변수에 값을 넣고, 함수를 호출한다. 함수 호출 시 현재 실행을 멈추고 함수로 점프한다.
- **함수 코드 평가**: 함수 내부의 매개변수, 지역 변수를 파악하여 함수 실행 컨텍스트의 지역 스코프에 등록한다. `this` 값도 결정한다.
- **함수 코드 실행**: 매개변수와 지역 변수에 값을 할당하고, 함수 내부 코드를 실행한다. 함수 실행이 끝나면 원래 호출했던 곳으로 돌아가 멈췄던 코드 실행을 이어간다.

이 모든 과정에서 실행 컨텍스트는 "지금 어떤 변수를 써야 하지?", "이 함수 끝나면 어디로 가야 하지?" 같은 질문에 답을 주며 코드 실행을 지휘한다.

## 23.4 실행 컨텍스트 스택

자바스크립트 엔진은 실행 컨텍스트들을 **스택(Stack)**이라는 방식으로 차곡차곡 쌓아 관리한다. 이를 **실행 컨텍스트 스택** 또는 **콜 스택(Call Stack)**이라고 부른다.

- 코드가 처음 실행될 때, **전역 실행 컨텍스트**가 만들어져 스택의 맨 아래에 놓인다.
- 함수가 호출될 때마다, 해당 함수의 **함수 실행 컨텍스트**가 새로 만들어져 스택의 맨 위에 쌓인다.
- 스택의 맨 위에 있는 실행 컨텍스트가 현재 실행 중인 코드의 컨텍스트가 된다.
- 함수 실행이 끝나면, 해당 함수 실행 컨텍스트는 스택에서 제거된다(사라진다).
- 이런 식으로 함수를 호출하고 종료할 때마다 스택에 실행 컨텍스트가 쌓였다가 빠지면서 코드 실행 순서가 관리된다. 모든 코드가 실행되어 스택이 비면 프로그램이 종료된다.

예를 들어, `main()` 함수가 `foo()`를 호출하고, `foo()`가 `bar()`를 호출하면 스택은 다음과 같이 변한다.

1.  `main()` 실행 시: `[전역 컨텍스트, main 컨텍스트]`
2.  `foo()` 호출 시: `[전역 컨텍스트, main 컨텍스트, foo 컨텍스트]`
3.  `bar()` 호출 시: `[전역 컨텍스트, main 컨텍스트, foo 컨텍스트, bar 컨텍스트]`
4.  `bar()` 종료 시: `[전역 컨텍스트, main 컨텍스트, foo 컨텍스트]`
5.  `foo()` 종료 시: `[전역 컨텍스트, main 컨텍스트]`
6.  `main()` 종료 시: `[전역 컨텍스트]`
7.  전역 코드 종료 시: `[]` (스택 비워짐)

## 23.5 렉시컬 환경

**렉시컬 환경(Lexical Environment)**은 실행 컨텍스트의 중요한 일부로, "스코프와 식별자(변수, 함수 이름 등)를 어떻게 관리할 것인가?"에 대한 명세이다. 쉽게 말해, 각 스코프마다 변수와 함수들이 어떻게 기록되고, 그 값들이 무엇이며, 상위 스코프는 무엇인지를 담고 있는 내부 객체이다.

렉시컬 환경은 두 가지 주요 부분으로 구성된다.

1.  **환경 레코드(Environment Record)**:
    - 현재 스코프에 속한 식별자(변수, 함수 이름)들과 그 실제 값(또는 참조)을 기록하는 곳이다.
    - `var`, `let`, `const`로 선언된 변수, 함수 선언문으로 만들어진 함수 등이 여기에 등록된다.
2.  **외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)**:
    - 현재 스코프의 "바깥쪽 스코프", 즉 상위 스코프를 가리키는 포인터(참조)이다.
    - 이 참조를 따라 계속해서 상위 스코프로 이동할 수 있으며, 이것이 바로 **스코프 체인**을 가능하게 한다. 전역 렉시컬 환경의 외부 참조는 `null`이다 (더 이상 상위 스코프가 없음).

실행 컨텍스트는 `LexicalEnvironment`와 `VariableEnvironment`라는 두 컴포넌트를 가지는데, 대부분의 경우 이 둘은 같은 렉시컬 환경을 가리킨다. (특별한 경우에만 달라지므로, 보통은 하나의 렉시컬 환경으로 이해해도 무방하다.)

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

코드가 실행될 때 실행 컨텍스트와 렉시컬 환경이 어떻게 만들어지고, 변수나 함수를 어떻게 찾아 사용하는지 간단한 흐름을 살펴보자.

**1. 전역 객체 생성**
코드가 평가되기 전에 자바스크립트 엔진은 전역 객체(브라우저에서는 `window`, Node.js에서는 `global`)를 먼저 만든다. 여기에는 기본 빌트인 함수, 객체들이 들어있다.

**2. 전역 코드 평가** (예: `var x = 1; const y = 2; function foo() {}`)

- **전역 실행 컨텍스트 생성**: 스택에 푸시된다.
- **전역 렉시컬 환경 생성**:
  - **환경 레코드 생성**:
    - **객체 환경 레코드**: `var x`와 `function foo` 같은 선언을 처리한다. `x`는 `undefined`로, `foo`는 함수 객체로 전역 객체의 프로퍼티처럼 만들어진다. (이것이 `var` 변수와 함수 선언의 호이스팅 방식이다.)
    - **선언적 환경 레코드**: `const y` 같은 선언을 처리한다. `y`는 전역 객체의 프로퍼티가 되지 않고, 초기화 전까지 TDZ(일시적 사각지대) 상태가 된다. (`let`, `const`의 호이스팅 방식)
  - **`this` 바인딩**: 전역 코드에서 `this`는 전역 객체를 가리키도록 설정된다.
  - **외부 렉시컬 환경 참조**: 전역이므로 `null`로 설정된다.

**3. 전역 코드 실행** (예: `x = 1; y = 2; foo();`)

- `x`와 `y`에 실제 값이 할당된다.
- `foo()` 함수가 호출된다. 이때 필요한 식별자(`x`, `y`, `foo`)는 현재 실행 중인 전역 실행 컨텍스트의 렉시컬 환경에서 찾는다. 없으면 에러가 발생한다.

**4. 함수 코드 평가** (예: `foo` 함수 내부로 진입 시)

- `foo` **함수 실행 컨텍스트 생성**: 스택의 맨 위에 푸시된다.
- `foo` **함수 렉시컬 환경 생성**:
  - **함수 환경 레코드 생성**: 매개변수, `arguments` 객체, 함수 내 지역 변수, 내부 함수 등을 등록한다.
  - **`this` 바인딩**: 함수 호출 방식에 따라 `this` 값이 결정된다. (일반 함수 호출 시 전역 객체 또는 `undefined` (엄격 모드))
  - **외부 렉시컬 환경 참조**: 함수가 **선언된 위치**(정의된 시점)의 렉시컬 환경을 가리킨다. (예: `foo`가 전역에 선언되었으면 전역 렉시컬 환경을 가리킴). 이것이 렉시컬 스코프(정적 스코프)의 핵심이다.

**5. 함수 코드 실행** (예: `foo` 함수 내부 코드 실행)

- 매개변수에 인수가 할당되고, 지역 변수에 값이 할당되는 등 내부 코드가 실행된다.
- 만약 함수 내에서 또 다른 함수(예: `bar`)를 호출하면, 위 4~5번 과정이 그 내부 함수에 대해 반복된다. 이때 `bar` 함수의 외부 렉시컬 환경 참조는 `bar`가 정의된 `foo`의 렉시컬 환경을 가리킨다.

**6. 식별자 검색**
코드가 특정 변수나 함수를 사용하려고 할 때, 엔진은 다음 순서로 해당 식별자를 찾는다. 1. 현재 실행 중인 실행 컨텍스트의 렉시컬 환경(의 환경 레코드)에서 찾아본다. 2. 없으면, 외부 렉시컬 환경 참조를 따라 상위 스코프의 렉시컬 환경으로 이동하여 찾아본다. 3. 계속해서 상위로 이동하며 찾다가 전역 렉시컬 환경까지 갔는데도 없으면, `ReferenceError`가 발생한다.

**7. 함수 실행 종료**

- 함수 실행이 끝나면, 해당 함수 실행 컨텍스트는 스택에서 제거(pop)된다.
- 제어권은 이전 실행 컨텍스트(호출한 함수 또는 전역)로 돌아간다.
- (주의) 실행 컨텍스트가 제거되어도, 그 렉시컬 환경은 내부 함수(클로저) 등에 의해 여전히 참조되고 있다면 즉시 사라지지 않고 메모리에 남아있을 수 있다.

## 23.7 실행 컨텍스트와 블록 레벨 스코프

`var`는 함수 전체를 하나의 스코프로 취급하지만(함수 레벨 스코프), `let`과 `const`는 `{}` 코드 블록마다 새로운 스코프를 만든다(블록 레벨 스코프).

`if`문이나 `for`문 등의 코드 블록 안에서 `let`이나 `const`로 변수를 선언하면, 해당 블록이 실행될 때 특별한 일이 일어난다.

1.  해당 블록만을 위한 새로운 **렉시컬 환경**이 만들어진다.
2.  이 새로운 렉시컬 환경은 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 일시적으로 대체한다. (정확히는 현재 컨텍스트가 이 새로운 렉시컬 환경을 사용하도록 잠시 바뀐다.)
3.  이 새로운 블록 렉시컬 환경의 "외부 렉시컬 환경 참조"는 이전 렉시컬 환경(예: `if`문이 있던 함수나 전역의 렉시컬 환경)을 가리킨다.
4.  블록 실행이 끝나면, 현재 실행 컨텍스트는 원래의 렉시컬 환경으로 돌아간다.

`for (let i = 0; ...)` 처럼 `for`문에서 `let`을 사용하면, 반복할 때마다 `i`를 포함한 코드 블록을 위한 새로운 렉시컬 환경이 만들어져 각 반복이 독립적인 스코프를 가지게 된다. 이것이 클로저와 함께 사용될 때 각 반복의 상태를 정확히 기억하는 비결이다.
